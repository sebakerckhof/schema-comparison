const FasterSchema = require('faster-schema').default;

const {
  recordingState,
  status,
  audioSinkRole,
  audioSourceRole,
  usbCameraSettingType,
  cameraRole,
  moderationPolicy,
  deviceRole,
  roomRole,
  displayRole,
} = require('./constants');

const proxySchema = new FasterSchema({
  url: {
    type: String,
    defaultValue: '',
    max: 2048,
  },
  user: {
    type: String,
    defaultValue: '',
    optional: true,
    max: 255,
  },
  password: {
    type: String,
    defaultValue: '',
    optional: true,
    max: 255,
  },
});

const hierarchySchema = new FasterSchema({
  _metadata: {
    type: Object,
  },
  '_metadata.master': {
    type: String,
    optional: true,
    max: 20,
  },
  '_metadata.isMaster': {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
});

const wallpaperCacheSchema = FasterSchema.merge(hierarchySchema, {
  _id: {
    type: String,
    defaultValue: '',
    optional: true,
    max: 20,
  },
  role: {
    type: String,
    optional: true,
  },
});

const displayModeSchema = new FasterSchema({
  width: {
    type: 'integer',
    autoValue({ value, isSet }) {
      if (isSet) {
        return Math.round(value);
      }
    },
  },
  height: {
    type: 'integer',
    autoValue({ value, isSet }) {
      if (isSet) {
        return Math.round(value);
      }
    },
  },
  rate: 'number',
  native: 'boolean?',
});

const displayBaseSchema = new FasterSchema({
  id: {
    type: String,
    max: 255,
  },
  port: {
    type: String,
    max: 255,
  },
  x: {
    type: 'integer?',
    autoValue({ value, isSet }) {
      if (isSet) {
        return Math.round(value);
      }
    },
  },
  y: {
    type: 'integer?',
    autoValue({ value, isSet }) {
      if (isSet) {
        return Math.round(value);
      }
    },
  },
  activeMode: {
    type: displayModeSchema,
    optional: true,
  },
});

const displaySchema = FasterSchema.merge(
  displayBaseSchema,
  {
    vendor: {
      type: String,
      optional: true,
    },
    model: {
      type: String,
      optional: true,
    },
    productCode: 'integer?',
    serial: 'integer?',
    modes: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
      optional: true,
    },
    'modes.$': {
      type: displayModeSchema,
    },
  });

const displayConfigSchema = FasterSchema.merge(displayBaseSchema, {
  role: {
    type: String,
    allowedValues: Object.values(displayRole),
    defaultValue: displayRole.IDLE,
    optional: true,
  },
  extends: {
    type: String,
    optional: true,
    max: 255,
  },
  parameters: {
    type: Object,
    blackbox: true,
    optional: true,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return {};
      }
      return value;
    },
  },
  isTouchScreen: {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
  title: {
    type: String,
    optional: true,
    max: 255,
  },
  isAutoGeneratedTitle: {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
});

const usbCameraSettingSchema = new FasterSchema({
  id: {
    type: 'integer',
  },
  name: {
    type: String,
    max: 500,
  },
  type: {
    type: String,
    allowedValues: Object.values(usbCameraSettingType),
  },
  min: {
    type: 'integer',
    defaultValue: 0,
  },
  max: {
    type: 'integer',
    defaultValue: 0,
  },
  default: {
    type: 'integer',
  },
  current: {
    type: 'integer',
  },
  step: {
    type: 'integer',
    defaultValue: 1,
  },
  menu: {
    type: Array,
    optional: true,
  },
  'menu.$': {
    type: String,
    max: 500,
  },
});

const framerateSchema = new FasterSchema({
  numerator: {
    type: 'integer',
  },
  denominator: {
    type: 'integer',
  },
});

const resolutionSchema = new FasterSchema({
  width: {
    type: 'integer',
  },
  height: {
    type: 'integer',
  },
});

const usbCameraResolutionSchema = FasterSchema.merge(
  resolutionSchema,
  {
    framerates: {
      type: Array,
      optional: true,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'framerates.$': {
      type: framerateSchema,
    },
  },
);

const formatSchema = new FasterSchema({
  id: {
    type: 'integer',
  },
  name: {
    type: String,
    max: 500,
  },
});

const usbCameraFormatSchema = FasterSchema.merge(
  formatSchema,
  {
    resolutions: {
      type: Array,
      optional: true,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'resolutions.$': {
      type: usbCameraResolutionSchema,
    },
  },
);

const usbCameraBaseSchema = new FasterSchema({
  id: {
    type: String,
    max: 500,
  },
  port: {
    type: 'integer',
    optional: true,
  },
  device: {
    type: String,
    optional: true,
    max: 500,
  },
  serial: {
    type: String,
    optional: true,
    defaultValue: '',
    max: 500,
  },
  vendor: {
    type: String,
    optional: true,
    defaultValue: '',
    max: 500,
  },
  model: {
    type: String,
    optional: true,
    defaultValue: '',
    max: 500,
  },
  activeFormat: {
    type: formatSchema,
    optional: true,
  },
  activeResolution: {
    type: resolutionSchema,
    optional: true,
  },
  activeFramerate: {
    type: framerateSchema,
    optional: true,
  },
});

const usbCameraSchema = FasterSchema.merge(usbCameraBaseSchema, {
  settings: {
    type: Array,
    optional: true,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'settings.$': {
    type: usbCameraSettingSchema,
  },
  formats: {
    type: Array,
    optional: true,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'formats.$': {
    type: usbCameraFormatSchema,
  },
});

const usbCameraConfigSchema = FasterSchema.merge(usbCameraBaseSchema, {
  title: {
    type: String,
    optional: true,
    max: 500,
  },
  isAutoGeneratedTitle: {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
  role: {
    type: String,
    optional: true,
    allowedValues: Object.values(cameraRole),
  },
  audioDevice: {
    type: String,
    optional: true,
  },
  stream: {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
  useLocally: {
    type: Boolean,
    optional: true,
    defaultValue: false,
  },
});

const audioPortSchema = new FasterSchema({
  id: {
    type: String,
    max: 500,
  },
  title: {
    type: String,
    max: 500,
  },
  available: {
    type: 'integer',
    optional: true,
  },
});

const audioSourceBaseSchema = new FasterSchema({
  id: {
    type: String,
    max: 500,
  },
  device: {
    type: String,
    optional: true,
    max: 500,
  },
  serial: {
    type: String,
    optional: true,
    max: 500,
  },
  activePort: {
    type: audioPortSchema,
    optional: true,
  },
});

const audioSourceSchema = FasterSchema.merge(
  audioSourceBaseSchema,
  {
    ports: {
      type: Array,
      optional: true,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'ports.$': {
      type: audioPortSchema,
    },
  },
);

const audioSourceConfigSchema = FasterSchema.merge(audioSourceBaseSchema, {
  title: {
    type: String,
    optional: true,
    max: 500,
  },
  role: {
    type: String,
    allowedValues: Object.values(audioSourceRole),
    optional: true,
    defaultValue: audioSourceRole.IDLE,
  },
});

const audioSinkBaseSchema = new FasterSchema({
  id: {
    type: String,
    max: 500,
  },
  device: {
    type: String,
    optional: true,
    max: 500,
  },
  activePort: {
    type: audioPortSchema,
    optional: true,
  },
});

const audioSinkSchema = FasterSchema.merge(
  audioSinkBaseSchema,
  {
    ports: {
      type: Array,
      optional: true,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'ports.$': {
      type: audioPortSchema,
    },
  },
);

const audioSinkConfigSchema = FasterSchema.merge(audioSinkBaseSchema, {
  title: {
    type: String,
    optional: true,
    max: 500,
  },
  role: {
    type: String,
    allowedValues: Object.values(audioSinkRole),
    optional: true,
    defaultValue: audioSinkRole.IDLE,
  },
});

// BASE
const baseSchema = new FasterSchema({
  // The title of the device, e.g. Whiteboard Camera
  title: {
    type: String,
    optional: true,
    max: 200,
  },
  // Type of device
  type: {
    type: String,
    max: 255,
  },
  model: {
    type: String,
    optional: true,
    max: 255,
  },
  // Institute ID, needs to be the same as the institute id of the location.
  instituteId: {
    type: String,
    max: 20,
  },
  // The reference to location (ID) this device lives in
  // Unique key of the device location, link towards Locations collection
  locationId: {
    type: String,
    optional: true,
    max: 20,
  },

  // List of document IDS of all ancestor location keys
  locations: {
    type: Array,
    optional: true,
  },
  'locations.$': {
    type: String,
    max: 20,
  },
  // Id of meeting which is controlling this device,
  meetingId: {
    type: String,
    optional: true,
    defaultValue: '',
    max: 20,
  },
});

// TYPES
const configurableDeviceSchema = new FasterSchema({
  activeConfigurationId: {
    type: String,
    optional: true,
    max: 20,
  },
  configured: {
    type: Boolean,
    defaultValue: false,
  },
});

const roleBasedDeviceSchema = new FasterSchema({
  role: {
    type: String,
    optional: true,
    max: 255,
  },
  parameters: {
    type: Object,
    blackbox: true,
    optional: true,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return {};
      }
      return value;
    },
  },
});

const stateBasedDeviceSchema = new FasterSchema({
  state: {
    type: String,
    optional: true,
    max: 255,
  },
  states: {
    type: Array,
    optional: true,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return {};
      }
      return value;
    },
  },
  'states.$': {
    type: Object,
  },
});

const baseDeviceState = new FasterSchema({
  state: {
    type: String,
    optional: true,
    max: 255,
  },
});

const networkManagedDeviceSchema = new FasterSchema({
  publicIp: {
    type: String,
    optional: true,
    max: 255,
  },
  privateIp: {
    type: String,
    optional: true,
    max: 255,
  },
  // The Hostname of the device, e.g. NRC-100-106wi673
  hostname: {
    type: String,
    optional: true,
    max: 255,
  },
  mac: {
    type: String,
    optional: true,
    autoValue({ isSet, value }) {
      if (isSet) {
        return value.toLowerCase();
      }
    },
    max: 255,
  },
  // The dns to connect with (roomname in NRC)
  dns: {
    type: String,
    optional: true,
    regEx: new RegExp('^[a-zA-Z0-9-._]*$'),
    max: 1024,
  },
  proxy: {
    type: FasterSchema.merge(hierarchySchema, proxySchema),
    optional: true,
  },
});

const connectedDeviceSchema = new FasterSchema({
  status: {
    type: 'integer',
    optional: true,
    defaultValue: status.UNKOWN,
    allowedValues: Object.values(status),
  },
  statusChangedAt: {
    type: Date,
    optional: true,
  },
});

const managedDeviceSchema = new FasterSchema({
  // User ID that controls this device
  managingUserId: {
    type: String,
    optional: true,
    max: 20,
  },
  rebootSchedule: {
    type: String,
    optional: true,
    defaultValue: '',
    max: 20,
  },
});

// AUDIO
const audioPropertiesSchema = new FasterSchema({
  mute: {
    type: Boolean,
    optional: true,
  },
  volume: {
    type: 'integer',
    min: 0,
    max: 100,
    optional: true,
  },
});

const audioDeviceState = FasterSchema.merge(baseDeviceState, {
  audio: {
    type: audioPropertiesSchema,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return {};
      }
      return value;
    },
  },

});

const audioDeviceDynamicConfig = new FasterSchema({
  audioSinkConfig: {
    type: Array,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'audioSinkConfig.$': {
    type: audioSinkConfigSchema,
  },
  audioSourceConfig: {
    type: Array,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'audioSourceConfig.$': {
    type: audioSourceConfigSchema,
  },
});

const audioDeviceSchema = FasterSchema.merge(
  audioDeviceState,
  audioDeviceDynamicConfig,
  {
    audioSinksLatest: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'audioSinksLatest.$': {
      type: audioSinkSchema,
    },
    audioSinks: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'audioSinks.$': {
      type: audioSinkSchema,
    },
    audioSourcesLatest: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'audioSourcesLatest.$': {
      type: audioSourceSchema,
    },
    audioSources: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'audioSources.$': {
      type: audioSourceSchema,
    },
    audioSinksLocked: {
      type: Boolean,
      optional: true,
      defaultValue: false,
    },
    audioSourcesLocked: {
      type: Boolean,
      optional: true,
      defaultValue: false,
    },
  });


const usbCameraDeviceDynamicConfig = new FasterSchema({
  usbCameraConfig: {
    type: Array,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'usbCameraConfig.$': {
    type: usbCameraConfigSchema,
  },
});

const usbCameraDeviceSchema = FasterSchema.merge(
  usbCameraDeviceDynamicConfig,
  {
    usbCameras: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'usbCameras.$': {
      type: usbCameraSchema,
    },
    usbCamerasLatest: {
      type: Array,
      autoValue({ isSet, value }) {
        if (!isSet) {
          return [];
        }
        return value;
      },
    },
    'usbCamerasLatest.$': {
      type: usbCameraSchema,
    },
    usbCamerasLocked: {
      type: Boolean,
      optional: true,
      defaultValue: false,
    },

  });

const byodDeviceState = FasterSchema.merge(baseDeviceState, {
  byodCompositionId: {
    type: String,
    optional: true,
  },
  byodEnabled: {
    type: Boolean,
    optional: true,
  },
  moderated: {
    type: Boolean,
    optional: true,
  },
  moderationPolicy: {
    type: 'integer',
    optional: true,
    allowedValues: Object.values(moderationPolicy),
  },
});

const byodDeviceSchema = FasterSchema.merge(byodDeviceState, {
  byodEnabled: {
    defaultValue: false,
  },
  moderated: {
    defaultValue: true,
  },
  moderationPolicy: {
    defaultValue: moderationPolicy.ALLOW_NONE,
  },
  byodAccessCode: {
    type: 'integer',
    optional: true,
  },
  dongleAccessCode: {
    type: 'integer',
    min: 1000,
    max: 9999,
    optional: true,
  },
});

const displayDeviceDynamicConfig = new FasterSchema({
  wallpaper: {
    type: wallpaperCacheSchema,
    optional: true,
  },
  displayConfig: {
    type: Array,
    autoValue({ isSet, value }) {
      if (!isSet) {
        return [];
      }
      return value;
    },
  },
  'displayConfig.$': {
    type: displayConfigSchema,
  },
});

const displayDeviceState = FasterSchema.merge(baseDeviceState, {});

const displayDeviceSchema = FasterSchema.merge(
  displayDeviceState,
  displayDeviceDynamicConfig,
  {
    displaysLatest: {
      type: Array,
      autoValue() {
        if (!this.isSet) {
          return [];
        }
      },
    },
    'displaysLatest.$': {
      type: displaySchema,
    },
    displays: {
      type: Array,
      autoValue() {
        if (!this.isSet) {
          return [];
        }
      },
    },
    'displays.$': {
      type: displaySchema,
    },
    displaysLocked: {
      type: Boolean,
      optional: true,
      defaultValue: false,
    },
  });

const recordableDeviceState = FasterSchema.merge(baseDeviceState, {
  recording: {
    type: 'integer',
    optional: true,
    allowedValues: Object.values(recordingState),
  },
});

const recordableDeviceSchema = FasterSchema.merge(recordableDeviceState, {
  recording: {
    defaultValue: recordingState.STOPPED,
  },
  recorder: {
    type: Object,
    optional: true,
  },
  'recorder.enabled': {
    type: Boolean,
  },
  'recorder.ip': {
    type: String,
    defaultValue: '',
    max: 255,
  },
  'recorder.port': {
    type: String,
    defaultValue: '',
    max: 6,
  },
  'recorder.password': {
    type: String,
    defaultValue: '',
    max: 255,
  },
});

const displayNodeDeviceState = FasterSchema.merge(
  displayDeviceState,
  audioDeviceState,
  byodDeviceState,
  recordableDeviceState,
);

const displayNodeDeviceSchema = FasterSchema.merge(
  baseSchema,
  managedDeviceSchema,
  configurableDeviceSchema,
  roleBasedDeviceSchema,
  networkManagedDeviceSchema,
  connectedDeviceSchema,

  stateBasedDeviceSchema,

  displayNodeDeviceState,
  displayDeviceSchema,
  usbCameraDeviceSchema,
  audioDeviceSchema,

  byodDeviceSchema,

  recordableDeviceSchema,
  {
    role: {
      allowedValues: Object.values(deviceRole),
    },
    version: {
      type: String,
      optional: true,
      defaultValue: '0.0.1',
      max: 50,
    },

    'states.$': {
      type: displayNodeDeviceState,
    },

    lockImports: {
      type: 'integer',
      optional: true,
      defaultValue: 0,
    },
  },
);

module.exports = displayNodeDeviceSchema;
